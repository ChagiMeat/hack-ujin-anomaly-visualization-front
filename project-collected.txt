.gitignore
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

.idea

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts


generateTxtForGpt.mjs
import fs from 'fs';
import path from 'path';

// Исключаемые директории и файлы
const EXCLUDE_DIRS = ['node_modules', '.git', 'dist', 'build', 'coverage', '.idea'];
const EXCLUDE_FILES = ['.env', '.DS_Store', 'package-lock.json', 'yarn.lock', 'README.md'];

// Функция для проверки, нужно ли исключить файл или директорию
function shouldExclude(filePath) {
  const baseName = path.basename(filePath);
  return EXCLUDE_DIRS.includes(baseName) || EXCLUDE_FILES.includes(baseName);
}

// Рекурсивная функция для обхода директорий
function collectFiles(dir, prefix = '') {
  let result = '';
  const items = fs.readdirSync(dir);

  for (const item of items) {
    const fullPath = path.join(dir, item);

    // Пропускаем исключаемые файлы/директории
    if (shouldExclude(fullPath)) continue;

    const stats = fs.statSync(fullPath);

    if (stats.isDirectory()) {
      // Если это директория, добавляем заголовок и рекурсивно обходим её
      result += `${prefix}${item}/\n`;
      result += collectFiles(fullPath, `${prefix}  `);
    } else if (stats.isFile()) {
      // Если это файл, читаем его содержимое
      result += `${prefix}${item}\n`;
      try {
        const content = fs.readFileSync(fullPath, 'utf8');
        result += `${content}\n\n`;
      } catch (err) {
        result += `  [Ошибка чтения файла: ${err.message}]\n\n`;
      }
    }
  }

  return result;
}

// Главная функция
function main() {
  const projectRoot = process.cwd(); // Корневая директория проекта
  const outputFilePath = path.join(projectRoot, 'project-collected.txt'); // Выходной файл

  console.log('Сборка файлов проекта...');
  const collectedData = collectFiles(projectRoot);

  // Записываем результат в файл
  fs.writeFileSync(outputFilePath, collectedData, 'utf8');
  console.log(`Проект успешно собран в файл: ${outputFilePath}`);
}

main();

index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>UJIN</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


package.json
{
  "name": "trade-bot-front",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint .",
    "lint:fix": "eslint --fix",
    "format": "prettier --write './**/*.{js,jsx,ts,tsx,css,md,json}' --config ./.prettierrc"
  },
  "dependencies": {
    "@ant-design/icons": "^6.0.0",
    "@react-three/drei": "^10.0.8",
    "@react-three/fiber": "^9.1.2",
    "@types/three": "^0.176.0",
    "antd": "^5.25.2",
    "axios": "^1.9.0",
    "mobx": "^6.13.7",
    "mobx-react": "^9.2.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-router": "^7.6.0",
    "react-router-dom": "^7.6.0",
    "three": "^0.176.0"
  },
  "devDependencies": {
    "@types/react": "^19.1.5",
    "@types/react-dom": "^19.1.5",
    "@typescript-eslint/eslint-plugin": "^8.32.1",
    "@typescript-eslint/parser": "^8.32.1",
    "@vitejs/plugin-react": "^4.4.1",
    "eslint": "^9.27.0",
    "eslint-config-prettier": "^10.1.5",
    "eslint-plugin-prettier": "^5.4.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "prettier": "^3.5.3",
    "typescript": "^5.8.3",
    "vite": "^6.3.5"
  }
}


public/
  vite.svg
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img"
     class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257">
    <defs>
        <linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%">
            <stop offset="0%" stop-color="#41D1FF"></stop>
            <stop offset="100%" stop-color="#BD34FE"></stop>
        </linearGradient>
        <linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%">
            <stop offset="0%" stop-color="#FFEA83"></stop>
            <stop offset="8.333%" stop-color="#FFDD35"></stop>
            <stop offset="100%" stop-color="#FFA800"></stop>
        </linearGradient>
    </defs>
    <path fill="url(#IconifyId1813088fe1fbc01fb466)"
          d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path>
    <path fill="url(#IconifyId1813088fe1fbc01fb467)"
          d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path>
</svg>

src/
  api/
    getDeviceInfo.ts
import axios, {AxiosResponse} from "axios";

export interface GetDeviceSignalsParamsI {
  apartmentId: string | number;
  eg: string;
}

export interface GetDeviceSignalsResponseI {
  command: string;
  error: number;
  message: string;
  data: GetDeviceSignalsDataI;
  connection: ConnectionInfoI;
  token: string;
  fromdomain: string;
  worktime: string;
}

interface GetDeviceSignalsDataI {
  apartment: ApartmentInfoI;
  signals: SignalsDataI;
}

interface ApartmentInfoI {
  apartment_id: string;
  apartment_title: string;
}

interface SignalsDataI {
  [serialNumber: string]: SignalItemI[];
}

export interface SignalItemI {
  intensity: number;
  name: string;
  signal_label: string;
}

interface ConnectionInfoI {
  server_real_ip: string;
  user_ip: string;
}

const $apartmentApi = axios.create({baseURL: 'https://api-uae-test.ujin.tech/api/huk/'})

export default class ApartmentService {
  private static readonly hukBaseUrl = 'get-device-signals/';

  static async getApartmentDevices(
    params: GetDeviceSignalsParamsI
  ): Promise<AxiosResponse<GetDeviceSignalsResponseI>> {
    return $apartmentApi.get<GetDeviceSignalsResponseI>(this.hukBaseUrl, {
      params: {
        apartment_id: params.apartmentId,
        eg: params.eg,
        egt: 6,
        token: 'con-10892-057f7948807f893374d5b4c8bdf397d3',
      }
    });
  }
}



    index.ts
/* eslint-disable @typescript-eslint/ban-ts-comment */
import axios, { AxiosError, AxiosResponse, InternalAxiosRequestConfig } from 'axios';
import { BASE_URL, TOKEN } from '../consts.ts';
import { storage } from '../utils/localStorage.ts';
import UserStore from '../store/userStore.ts';

const $api = axios.create({
  baseURL: BASE_URL,
});

const requestInterceptor = (config: InternalAxiosRequestConfig<AxiosResponse>) => {
  const token = storage.get(TOKEN);
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
};

const responseInterceptor = async (error: AxiosError) => {
  const config = error.config;
  //@ts-ignore
  if (error?.response?.status === 401 && error.config && !error.config!._isRetry) {
    //@ts-ignore
    config!._isRetry = true;
    try {
      await UserStore.renew();
      if (config) return $api.request(config);
    } catch (e) {
      console.error(e);
    }
  }
  throw error;
};

$api.interceptors.request.use(requestInterceptor);

$api.interceptors.response.use((config) => config, responseInterceptor);

export default $api;


    loginService.ts
import {
  CreateUserRequestI,
  CreateUserResponseI,
  CreateUserSessionRequestI,
  CreateUserSessionResponseI,
  RenewUserTokensRequestI,
  RenewUserTokensResponseI,
} from '../types/user.types.ts';
import { AxiosResponse } from 'axios';
import $api from './index.ts';

export default class LoginService {
  private static readonly loginBaseUrl = '/user';

  static async registration(data: CreateUserRequestI): Promise<AxiosResponse<CreateUserResponseI>> {
    return $api.post<CreateUserResponseI>(this.loginBaseUrl, data);
  }

  static async login(
    data: CreateUserSessionRequestI
  ): Promise<AxiosResponse<CreateUserSessionResponseI>> {
    return $api.post<CreateUserSessionResponseI>(`${this.loginBaseUrl}/session`, data);
  }

  static async logout(): Promise<AxiosResponse> {
    return $api.delete<CreateUserSessionResponseI>(`${this.loginBaseUrl}/session`);
  }

  static async checkAuth(): Promise<AxiosResponse> {
    return $api.get(`${this.loginBaseUrl}/session/check`);
  }

  static async renewTokens(
    data: RenewUserTokensRequestI
  ): Promise<AxiosResponse<RenewUserTokensResponseI>> {
    return $api.put(`${this.loginBaseUrl}/session`, data);
  }
}


  components/
    HUApartmentScene/
      HUApartmentScene.tsx
import {Box, ContactShadows, OrbitControls, Plane, SoftShadows} from "@react-three/drei";
import {Canvas, useThree} from "@react-three/fiber";
import {Cylinder} from "@react-three/drei/core/shapes";
import {SignalItemI} from "../../api/getDeviceInfo.ts";
import {Vector3} from "three";

interface DevicesCoordinates {
  position: [number, number, number];
  rotation: [number, number, number];
  color: string;
}

const DEVICES_COORDINATES: DevicesCoordinates[] = [
  {
    position: [-0.2, 0.7, -1.9],
    rotation: [Math.PI / 2, 0, 0],
    color: '#27EB96',
  },
  {
    position: [-0.2, 0.7, 0.55],
    rotation: [Math.PI / 2, 0, 0],
    color: '#27EB96',
  },
  {
    position: [0.4, 0.7, 0.55],
    rotation: [Math.PI / 2, 0, 0],
    color: '#27EB96',
  },
  {
    position: [-1.4, 0.7, -1.9],
    rotation: [Math.PI / 2, 0, 0],
    color: '#27EB96',
  },
  {
    position: [-1.4, 0.7, 1.9],
    rotation: [Math.PI / 2, 0, 0],
    color: '#27EB96',
  },
  {
    position: [-0.75, 0.7, 0.4],
    rotation: [Math.PI / 2, 0, Math.PI / 2],
    color: '#27EB96',
  },
  {
    position: [-2, 0.7, 0.4],
    rotation: [Math.PI / 2, 0, Math.PI / 2],
    color: '#27EB96',
  },
  {
    position: [2, 0.7, -1],
    rotation: [Math.PI / 2, 0, Math.PI / 2],
    color: '#27EB96',
  },
  {
    position: [1.5, 0.7, 1.9],
    rotation: [Math.PI / 2, 0, 0],
    color: '#27EB96',
  },
  {
    position: [-0.65, 0.7, 1.6],
    rotation: [Math.PI / 2, 0, Math.PI / 2],
    color: '#27EB96',
  },
];

function ApartmentScene() {
  const { camera } = useThree()

  function lookAt(position: [number, number, number]) {
    camera.lookAt(...position)
  }

  return (
    <>
      {/*Датчик*/}
      {DEVICES_COORDINATES.map(({position, rotation, color}) => (
        <Cylinder
          onClick={() => lookAt(position)}
          onPointerOver={() => (document.body.style.cursor = 'pointer')}
          onPointerOut={() => (document.body.style.cursor = 'auto')}
          receiveShadow
          castShadow
          position={position}
          rotation={rotation}
          args={[0.1, 0.1, 0.1]}
        >
          <meshStandardMaterial color={color}/>
        </Cylinder>
      ))}

      {/* Плоскость пола */}
      <Plane args={[4, 4]} rotation={[-Math.PI / 2, 0, 0]} receiveShadow>
        <meshStandardMaterial color="lightgray"/>
      </Plane>

      {/* Стены как коробки */}
      <Box receiveShadow castShadow position={[0, 0.5, -1.95]} args={[4, 1, 0.1]}>
        <meshStandardMaterial color="white"/>
      </Box>
      <Box receiveShadow castShadow position={[2.05, 0.5, 0]} args={[0.1, 1, 4]}>
        <meshStandardMaterial color="white"/>
      </Box>
      <Box receiveShadow castShadow position={[0, 0.5, 1.95]} args={[4, 1, 0.1]}>
        <meshStandardMaterial color="white"/>
      </Box>
      <Box receiveShadow castShadow position={[0.1, 0.5, 0.6]} args={[1.7, 1, 0.1]}>
        <meshStandardMaterial color="white"/>
      </Box>
      <Box receiveShadow castShadow position={[1.8, 0.5, 0.6]} args={[0.5, 1, 0.1]}>
        <meshStandardMaterial color="white"/>
      </Box>
      <Box receiveShadow castShadow position={[-2.05, 0.5, 0]} args={[0.1, 1, 4]}>
        <meshStandardMaterial color="white"/>
      </Box>
      <Box receiveShadow castShadow position={[-0.7, 0.5, 1]} args={[0.1, 1, 2]}>
        <meshStandardMaterial color="white"/>
      </Box>
      <Box receiveShadow castShadow position={[-0.7, 0.5, -1.2]} args={[0.1, 1, 1.4]}>
        <meshStandardMaterial color="white"/>
      </Box>
      <Box receiveShadow castShadow position={[-1.8, 0.5, -1]} args={[0.4, 1, 0.1]}>
        <meshStandardMaterial color="white"/>
      </Box>
      <Box receiveShadow castShadow position={[-0.9, 0.5, -1]} args={[0.4, 1, 0.1]}>
        <meshStandardMaterial color="white"/>
      </Box>
    </>
  )
}

interface HUApartmentScenePropsI {
  devices?: SignalItemI[];
}

export default function HUApartmentScene({devices}: HUApartmentScenePropsI) {
  return (
    <Canvas
      style={{width: 600, height: 600}}
      camera={{
        fov: 50,
        far: 100,
        near: 0.1,
        position: [0, 7, 0]
      }}
      gl={{
        antialias: true,
        powerPreference: "high-performance",
      }}
      shadows
    >
      <ApartmentScene/>

      <OrbitControls
        enableRotate
        minPolarAngle={Math.PI / 5}
        maxPolarAngle={Math.PI / 2}
        minDistance={8}
        maxDistance={8}
        enablePan={false}
        target={[0, 0.5, 0]}
      />

      <hemisphereLight
        color="white"
        groundColor="#171717"
        intensity={0.8}
      />

      {/* Основной направленный свет */}
      <directionalLight
        position={[5, 10, 5]}
        intensity={1.2}
        castShadow={true}
        shadow-mapSize-width={2048}
        shadow-mapSize-height={2048}
        shadow-camera-near={0.1}
        shadow-camera-far={50}
        shadow-camera-left={-20}
        shadow-camera-right={20}
        shadow-camera-top={20}
        shadow-camera-bottom={-20}
        shadow-bias={-0.0001} // Уменьшает артефакты
        shadow-normalBias={0.05} // Улучшает качество теней
      />

      {/* Дополнительный мягкий свет сбоку */}
      <directionalLight
        position={[-10, 5, 0]}
        intensity={0.4}
        castShadow={false}
      />

      <ContactShadows
        position={[0, -0.01, 0]}
        opacity={0.6}
        scale={10}
        blur={2}
        far={10}
      />

      <SoftShadows size={25} samples={16}/>
      <ambientLight intensity={1}/>
      <directionalLight
        position={[5, 5, 5]}
        intensity={1.5}
        castShadow={true}
      />
    </Canvas>
  )
}


    HULoadingBar/
      HULoadingBar.module.css
.wrapper {
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 10px;
}

.icon {
  font-size: 32px;
}


      HULoadingBar.tsx
import cls from './HULoadingBar.module.css';
import { LoadingOutlined } from '@ant-design/icons';

export default function HULoadingBar() {
  return (
    <div className={cls.wrapper}>
      <LoadingOutlined className={cls.icon} size={32} />
    </div>
  );
}


  consts.ts
export const BASE_URL = 'http://localhost:8000/api/v1';
export const TOKEN = 'token';
export const REFRESH_TOKEN = 'refresh_token';

export const THEME = 'theme'

export enum Colors {
  Warning = '#fa8c43',
  DarkBg = '#151518',
  LightBg = '#fff',
}


  index.css
@import url('https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap');

:root {
  --bg-color: white;
}

* {
  box-sizing: border-box;
}

html,
body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100dvh;
  font-family: 'Lato', sans-serif;
  background-color: var(--bg-color);
}

.main {
  width: 100%;
  height: 100dvh;
  max-width: 1200px;
  margin: auto;
  display: flex;
  flex-direction: column;
}

input,
input[type='color'],
input[type='date'],
input[type='datetime'],
input[type='datetime-local'],
input[type='email'],
input[type='month'],
input[type='number'],
input[type='password'],
input[type='search'],
input[type='tel'],
input[type='text'],
input[type='time'],
input[type='url'],
input[type='week'],
select:focus,
textarea {
  opacity: 1;
}


  main.tsx
import ReactDOM from 'react-dom/client';
import './index.css';
import {createBrowserRouter, RouterProvider} from 'react-router-dom';
import AccountContainer from './pages/account/AccountContainer/AccountContainer.tsx';
import MainContainer from './pages/account/MainContainer/MainContainer.tsx';
import {Navigate} from 'react-router';
import AccountPage from './pages/account/AccountPage/AccountPage.tsx';
import MainPage from './pages/account/MainPage/MainPage.tsx';
import ApartmentDetailsPage from './pages/account/ApartmentDetailsPage/ApartmentDetailsPage.tsx';
import LoginPage from './pages/login/LoginPage.tsx';
import {ConfigProvider, theme} from 'antd';
import {observer} from 'mobx-react';
import ConfigStore from './store/configStore.ts';
import {useEffect} from 'react';

export const router = createBrowserRouter([
  {
    element: <AccountContainer/>,
    path: 'account',
    children: [
      {
        element: <MainContainer/>,
        path: '',
        children: [
          {
            path: '',
            element: <MainPage/>,
          },
          {
            path: 'apartment-details',
            element: <ApartmentDetailsPage/>,
          },
        ],
      },
      {
        element: <AccountPage/>,
        path: 'settings',
      },
    ],
  },
  {
    element: <LoginPage/>,
    path: 'login',
  },
  {
    element: <Navigate to={'/login'}/>,
    path: '*',
  },
]);

const App = observer(() => {
    useEffect(() => {
      ConfigStore.loadTheme();
    }, []);

    return (
      <main className='main'>
        <ConfigProvider
          theme={{algorithm: ConfigStore.theme === 'dark' ? theme.darkAlgorithm : theme.defaultAlgorithm}}>
          <RouterProvider router={router}/>
        </ConfigProvider>
      </main>
    );
  },
);

ReactDOM.createRoot(document.getElementById('root')!).render(<App/>);


  pages/
    ProtectedRoute/
      ProtectedRoute.tsx
import { PropsWithChildren, useEffect, useState } from 'react';

import UserStore from '../../store/userStore.ts';
import { Navigate } from 'react-router';
import HULoadingBar from '../../components/HULoadingBar/HULoadingBar.tsx';
import { observer } from 'mobx-react';

const ProtectedRoute = observer(function ({ children }: PropsWithChildren) {
  const [loading, setLoading] = useState<boolean>(true);
  useEffect(() => {
    UserStore.checkAuth().then(() => setLoading(false));
  }, []);

  const isAuth = UserStore.isAuth;

  if (loading) {
    return <HULoadingBar />;
  }

  if (!isAuth) {
    return <Navigate to={'/login'} />;
  }

  return <>{children}</>;
});

export default ProtectedRoute;


    account/
      AccountContainer/
        AccountContainer.module.css
.wrapper {
  width: 100%;
  height: 100dvh;
  padding: 10px;
  display: flex;
  flex-direction: column;
}


        AccountContainer.tsx
import cls from './AccountContainer.module.css';
import { Outlet } from 'react-router';

export default function AccountContainer() {
  return (
    <div className={cls.wrapper}>
      <Outlet />
    </div>
  );
}


      AccountPage/
        AccountPage.tsx
import { Button, Flex, Input, Modal, Space, Typography } from 'antd';
import { useNavigate } from 'react-router';
import { useState } from 'react';

export default function AccountPage() {
  const navigate = useNavigate();
  const [loading, setLoading] = useState<boolean>(false);
  const [passwordVisible, setPasswordVisible] = useState(false);
  const [disabled] = useState<boolean>(true);
  const [isModalOpen, setIsModalOpen] = useState<boolean>(false);

  function handleSave() {
    setLoading(true);
    setTimeout(() => {
      setLoading(false);
      navigate('/account');
    }, 700);
  }

  return (
    <>
      <Flex vertical flex='1' justify='space-between' align='stretch'>
        <div>
          <Typography.Title>Аккаунт</Typography.Title>
          <Space direction='vertical' style={{ padding: '50px 0 10px 0', width: '70%' }}>
            <Input
              disabled={disabled}
              variant='borderless'
              placeholder='Email'
              value='email@gmail.com'
            />
            <Input.Password
              disabled={disabled}
              variant='borderless'
              placeholder='Пароль'
              value='123123123123'
              visibilityToggle={{ visible: passwordVisible, onVisibleChange: setPasswordVisible }}
            />
          </Space>
        </div>

        <Space direction='vertical'>
          <Button block type='primary' loading={loading} onClick={handleSave}>
            Сохранить
          </Button>
          <Button
            block
            type='dashed'
            danger
            onClick={() => {
              setIsModalOpen(true);
              // navigate('/login');
            }}
          >
            Выход
          </Button>
          <Button block type='text' onClick={() => navigate('/account')}>
            На главную
          </Button>
        </Space>
      </Flex>

      <Modal
        centered
        title='Подтвердите выход'
        open={isModalOpen}
        onOk={() => navigate('/login')}
        onCancel={() => setIsModalOpen(false)}
        okText='Да'
        cancelText='Отмена'
      >
        <p>Вы действительно хотите выйти?</p>
      </Modal>
    </>
  );
}


      ApartmentDetailsPage/
        ApartmentDetailsPage.tsx
import {Card, Flex, Progress, Typography} from 'antd';
import HUApartmentScene from "../../../components/HUApartmentScene/HUApartmentScene.tsx";
import {useSearchParams} from "react-router-dom";
import {useEffect} from "react";
import ApartmentStore from "../../../store/appartmentStore.ts";
import {observer} from "mobx-react";

const ApartmentDetailsPage = observer(() => {
  const [searchParams] = useSearchParams();
  const apartmentId = searchParams.get('apartmentId');
  const eg = searchParams.get('eg');

  useEffect(() => {
    if(apartmentId && eg) {
      void ApartmentStore.fetchApartmentDevices({apartmentId, eg});
    }
  }, []);

  return (
    <Flex flex='1' justify='center' align='center'>
      <Flex gap={12} style={{width: '100%', height: '100%'}} vertical align='flex-start'>
        <Typography.Title level={2}>Список устройств</Typography.Title>
        <Flex vertical gap={12} style={{ width: '80%', overflowY: 'auto'}}>
          {ApartmentStore.allDevicesInfo.map(item => (
            <Card style={{width: '100%'}}>
              <Flex justify='space-between'>
                <Flex vertical>
                  <Typography.Text strong>{item.signal_label}</Typography.Text>
                  <Typography.Text type='secondary'>{item.name}</Typography.Text>
                </Flex>
                <Progress
                  strokeWidth={12}
                  size={60}
                  strokeColor={ApartmentStore.getIntencityColor(item.intensity)}
                  type="circle"
                  percent={(Number(item.intensity) / 10) * 100}
                  format={(percent) => `${Number(percent).toFixed(2)}`}
                />
              </Flex>
            </Card>
          ))}
        </Flex>
      </Flex>
      <Flex style={{height: '100%'}}>
        <HUApartmentScene/>
      </Flex>
    </Flex>
  );
});

export default ApartmentDetailsPage;


      MainContainer/
        MainContainer.module.css
.mainContainer {
  flex: 1;
  display: flex;
  padding: 50px 0 10px 0;
}


        MainContainer.tsx
import {Button, Flex, Segmented, Space, Switch, Typography} from 'antd';
import {
  HomeOutlined,
  LineChartOutlined,
  LoadingOutlined,
  MoonOutlined,
  SunOutlined,
  ThunderboltTwoTone,
  UserOutlined,
} from '@ant-design/icons';
import {Outlet, useLocation, useNavigate} from 'react-router';
import {SegmentedLabeledOption} from 'rc-segmented';
import cls from './MainContainer.module.css';
import {useEffect, useState} from 'react';
import {observer} from 'mobx-react';
import ConfigStore from '../../../store/configStore.ts';
import ApartmentStore from "../../../store/appartmentStore.ts";

const segmentedConfig: SegmentedLabeledOption<string>[] = [
  {
    label: (
      <Space>
        <HomeOutlined/>
        Главная
      </Space>
    ),
    value: '',
    disabled: false,
  },
  {
    label: (
      <Space>
        <LineChartOutlined/>
        Детализация
      </Space>
    ),
    value: 'apartment-details',
    disabled: false,
  },
];

function MainContainer() {
  const navigate = useNavigate();
  const location = useLocation();
  const [currentSelection, setCurrentSelection] = useState<string>(segmentedConfig[0].value);
  const [isLoadingGlobal, setIsLoadingGlobal] = useState<boolean>(false);

  useEffect(() => {
    setCurrentSelection(
      segmentedConfig.toReversed().find((segment) => location.pathname.includes(segment.value))
        ?.value ?? segmentedConfig[0].value,
    );
  }, [location]);

  useEffect(() => {
    const isLoading = ApartmentStore.isLoading;
    setIsLoadingGlobal(isLoading);
  }, [ApartmentStore.isLoading]);

  return (
    <>
      <Flex justify='space-between' align='center'>
        <Space>
          <Typography.Title>Личный кабинет UJIN</Typography.Title>
          {ConfigStore.isWorking && <ThunderboltTwoTone/>}
          {isLoadingGlobal && <LoadingOutlined style={{fontSize: 32}} size={32}/>}
        </Space>

        <Space size='large'>
          <Switch
            onChange={checked => {
              ConfigStore.changeTheme(checked ? 'dark' : 'light');
            }}
            checkedChildren={<MoonOutlined/>}
            unCheckedChildren={<SunOutlined/>}
            checked={ConfigStore.theme === 'dark'}
          />
          <Button
            onClick={() => navigate('settings')}
            type='text'
            icon={<UserOutlined style={{fontSize: 24}}/>}
          />
        </Space>
      </Flex>

      <Segmented<string>
        block
        options={segmentedConfig}
        onChange={(value) => navigate(value)}
        defaultValue={currentSelection}
        value={currentSelection}
      />
      <div className={cls.mainContainer}>
        <Outlet/>
      </div>
    </>
  );
}

export default observer(MainContainer);

      MainPage/
        MainPage.tsx
import { Button, Flex, Space, Typography } from 'antd';
import {useEffect, useState} from 'react';
import { ExclamationCircleOutlined } from '@ant-design/icons';
import { Colors } from '../../../consts.ts';
import { Link } from 'react-router-dom';
import { observer } from 'mobx-react';
import ConfigStore from '../../../store/configStore.ts';
import DeviceService from "../../../api/getDeviceInfo.ts";

function MainPage() {
  const [active, setActive] = useState<boolean>(ConfigStore.isWorking);
  const [loading, setLoading] = useState<boolean>(false);

  function handleStartButton() {
    setLoading(true);
    setTimeout(() => {
      setLoading(false);
      setActive((prevState) => {
        ConfigStore.isWorking = !prevState;
        return !prevState;
      });
    }, 700);
  }

  useEffect(() => {
    void DeviceService.getApartmentDevices({apartmentId: '2117', eg: '2fc4f90a-346d-4d1c-aebc-6ff45a9c3136'})
  }, []);

  return (
    <Flex vertical justify='center' align='center' flex='1'>
      <Space direction='vertical' align='center' size='middle'>
        <Button
          loading={loading}
          onClick={handleStartButton}
          type='primary'
          size='large'
          danger={active}
        >
          {!active ? 'Запуск' : 'Отмена'}
        </Button>
        <Typography.Text type='secondary'>
          <ExclamationCircleOutlined style={{ color: Colors.Warning }} />
          &nbsp; Перед запуском бота проверьте&nbsp;
          <Link to={'/account/configuration'}>настройки</Link>
        </Typography.Text>
      </Space>
    </Flex>
  );
}

export default observer(MainPage);


    login/
      LoginPage.tsx
import { Button, Flex, Input, Space, Typography } from 'antd';
import { useState } from 'react';
import { useNavigate } from 'react-router';

export default function LoginPage() {
  const navigate = useNavigate();
  const [loading, setLoading] = useState<boolean>(false);
  const [passwordVisible, setPasswordVisible] = useState(false);

  function handleEnter() {
    setLoading(true);
    setTimeout(() => {
      setLoading(false);
      navigate('/account');
    }, 700);
  }

  return (
    <Flex vertical align="center" justify="center" flex="1">
      <Space direction="vertical" size="large">
        <Typography.Title style={{ textAlign: 'center' }}>Ujin<br/> Личный кабинет</Typography.Title>

        <Space direction="vertical" style={{width: '100%'}}>
          <Input variant="filled" placeholder="Email" />
          <Input.Password
            variant="filled"
            placeholder="Пароль"
            visibilityToggle={{ visible: passwordVisible, onVisibleChange: setPasswordVisible }}
          />
        </Space>

        <Button block type="primary" loading={loading} onClick={handleEnter}>
          Вход
        </Button>
      </Space>
    </Flex>
  );
}


  store/
    appartmentStore.ts
import {makeAutoObservable} from "mobx";
import ApartmentService, {
  GetDeviceSignalsParamsI,
  GetDeviceSignalsResponseI,
  SignalItemI
} from "../api/getDeviceInfo.ts";

class ApartmentStore {
  private allData: GetDeviceSignalsResponseI | null = null;
  isLoading = false;

  constructor() {
    makeAutoObservable(this);
  }

  getIntencityColor(intencity: number): string {
    if (intencity < 0) return 'green';
    if (intencity < 5) return 'yellow';
    if (intencity < 10) return 'orange';
    return 'red';
  }

  get allSerialNumbers(): number[] {
    return Object.keys(this.allData?.data.signals ?? {}).map(Number);
  }

  get allDevicesInfo(): SignalItemI[] {
    const result: SignalItemI[] = [];

    this.allSerialNumbers.forEach(serialNumber => {
      const devices = this.allData?.data.signals[serialNumber]
      if(devices) result.push(...devices);
    })
    return result;
  }

  async fetchApartmentDevices(params: GetDeviceSignalsParamsI): Promise<void>{
    this.isLoading = true;
    try {
      const response = await ApartmentService.getApartmentDevices(params);
      this.allData = response.data;
      this.isLoading = false;
    } catch (e) {
      this.isLoading = false;
      throw new Error('Error while fetching apartment devices');
    }
  }
}

export default new ApartmentStore();


    configStore.ts
import { makeAutoObservable } from 'mobx';
import { Colors, THEME } from '../consts.ts';

class ConfigStore {
  isWorking = false;
  private _theme: 'dark' | 'light' = 'dark';

  constructor() {
    makeAutoObservable(this);
  }

  get theme() {
    return this._theme;
  }

  changeTheme(theme: typeof this._theme){
        const doc = document.documentElement;
        doc.style.setProperty('--bg-color', theme === 'dark' ? Colors.DarkBg : Colors.LightBg);
        this._theme = theme;
        localStorage.setItem(THEME, theme);
  }

  loadTheme() {
    const savedTheme = localStorage.getItem(THEME);
    this._theme =  savedTheme === 'dark' || savedTheme === 'light' ? savedTheme : 'dark';
    const doc = document.documentElement;
    doc.style.setProperty('--bg-color', this._theme === 'dark' ? Colors.DarkBg : Colors.LightBg);
  }
}

export default new ConfigStore();


    notificationStore.ts
import { makeAutoObservable } from 'mobx';
import { ErrorI } from '../utils/errorHandler.ts';

export interface MessageI {
  id: number;
  timeoutId: number;
  message: string;
  type?: 'error' | 'warning' | 'notification';
  onClose: () => void;
}

export interface NotificationServiceI {
  showError: (message: string) => void;
  showWarning: (message: string) => void;
  showNotification: (message: string) => void;
  show: (message: string, type: ErrorI['type']) => void;
}

class NotificationStore implements NotificationServiceI {
  private _messagesQueue: MessageI[] = [];
  private readonly _timeout = 3000;

  constructor() {
    makeAutoObservable(this);
  }

  get messages(): MessageI[] {
    return this._messagesQueue;
  }

  showError(message: string): void {
    this.showMessage(message, 'error');
  }

  showWarning(message: string): void {
    this.showMessage(message, 'warning');
  }

  showNotification(message: string): void {
    this.showMessage(message, 'notification');
  }

  show(message: string, type: MessageI['type']): void {
    this.showMessage(message, type);
  }

  private showMessage(message: string, type: MessageI['type']): void {
    const id = Date.now();
    const removeMessageHandler = () => this.removeMessageFromQueue(id);
    const timeoutId = setTimeout(removeMessageHandler, this._timeout);
    this.pushMessageQueue({ message, type, id, onClose: removeMessageHandler, timeoutId });
  }

  private pushMessageQueue(message: MessageI): void {
    this._messagesQueue.push(message);
  }

  private removeMessageFromQueue(id: MessageI['id']): void {
    const indexOfMessage = this._messagesQueue.map((message) => message.id).indexOf(id);
    const message = this._messagesQueue.splice(indexOfMessage, 1)[0];
    clearTimeout(message.timeoutId);
  }
}

export default new NotificationStore();


    userStore.ts
import { makeAutoObservable } from 'mobx';
import LoginService from '../api/loginService.ts';
import { storage } from '../utils/localStorage.ts';
import { REFRESH_TOKEN, TOKEN } from '../consts.ts';
import { router } from '../main.tsx';
import ErrorHandler, { ErrorI } from '../utils/errorHandler.ts';
import { CreateUserRequestI, CreateUserSessionRequestI, UserI } from '../types/user.types.ts';

class UserStore {
  isAuth = false;
  user?: UserI;
  private readonly _errorHandler = new ErrorHandler();

  constructor() {
    makeAutoObservable(this);
  }

  setAuth(isAuth: boolean) {
    this.isAuth = isAuth;
  }

  setUser(user: UserI) {
    this.user = user;
  }

  async login(data: CreateUserSessionRequestI) {
    try {
      const response = await LoginService.login(data);
      storage.set(TOKEN, response.data.access_token);
      storage.set(REFRESH_TOKEN, response.data.refresh_token);
      this.setAuth(true);
      this.setUser({ uuid: response.data.uuid });
      await router.navigate('/account');
      return response;
    } catch (e: unknown) {
      const errorsConfig: ErrorI[] = [{ errorText: 'Неверный логин или пароль', code: 401 }];
      this._errorHandler.handleError(e, errorsConfig);
    }
  }

  async registration(data: CreateUserRequestI) {
    try {
      const response = await LoginService.registration(data);
      this.setUser({ uuid: response.data.uuid });
      await router.navigate('/login');
      return response;
    } catch (e) {
      const errorsConfig: ErrorI[] = [{ errorText: 'Пользователь уже существует', code: 400 }];
      this._errorHandler.handleError(e, errorsConfig);
    }
  }

  async logout() {
    try {
      await LoginService.logout();
      //TODO а будет ли ошибка, если я не брошу запрос при логауте?
      storage.remove(TOKEN);
      storage.remove(REFRESH_TOKEN);
      this.setAuth(false);
      await router.navigate('/login');
    } catch (e) {
      this._errorHandler.handleError(e);
    }
  }

  async renew() {
    try {
      const refreshToken = storage.get(REFRESH_TOKEN);
      //TODO удалить throw после того как разберусь с говнокодом в storage.get
      if (!refreshToken) throw new Error('refreshToken');
      const response = await LoginService.renewTokens({ refresh_token: refreshToken });
      this.setAuth(true);
      this.setUser({ uuid: response.data.uuid });
      storage.set(TOKEN, response.data.access_token);
      storage.set(REFRESH_TOKEN, response.data.refresh_token);
    } catch (e) {
      this.setAuth(false);
      const errorsConfig: ErrorI[] = [
        { errorText: 'Ошибка авторизации', code: 401 },
        { errorText: 'Ошибка авторизации', code: 404 },
      ];
      this._errorHandler.handleError(e, errorsConfig);
    }
  }

  async checkAuth() {
    try {
      await LoginService.checkAuth();
      this.setAuth(true);
    } catch (e) {
      this.setAuth(false);
      const errorsConfig: ErrorI[] = [{ errorText: 'Ошибка авторизации' }];
      this._errorHandler.handleError(e, errorsConfig);
    }
  }
}

export default new UserStore();


  types/
    user.types.ts
export interface UserI {
  uuid: string;
}

export interface CreateUserRequestI {
  login: string;
  password: string;
}

export interface CreateUserResponseI {
  uuid: string;
}

export interface CreateUserSessionRequestI extends CreateUserRequestI {}

export interface CreateUserSessionResponseI extends CreateUserResponseI {
  access_token: string;
  refresh_token: string;
}

export interface RenewUserTokensRequestI {
  refresh_token: string;
}

export interface RenewUserTokensResponseI extends CreateUserSessionResponseI {}


  types.d.ts
interface Mapping {
  [key: string]: string;
}

declare module '*.module.css' {
  const mapping: Mapping;
  export default mapping;
}
declare module '*.module.scss' {
  const mapping: Mapping;
  export default mapping;
}
declare module '*.module.sass' {
  const mapping: Mapping;
  export default mapping;
}
declare module '*.module.styl' {
  const mapping: Mapping;
  export default mapping;
}

declare module '*.svg?inline' {
  const content: any;
  export default content;
}

declare module '*.svg' {
  const content: string;
  export default content;
}

declare module '*.png' {
  const content: string;
  export default content;
}


  utils/
    errorHandler.ts
import NotificationStore, { NotificationServiceI } from '../store/notificationStore.ts';
import { isAxiosError } from 'axios';

export interface ErrorI {
  code?: number;
  errorText: string;
  type?: 'error' | 'warning' | 'notification';
  callback?: () => void;
}

export default class ErrorHandler {
  defaultErrors: ErrorI[] = [];
  private readonly _unexpectedErrorText = 'Неизвестная ошибка';
  private readonly _notificationService: NotificationServiceI = NotificationStore;

  handleError(error: unknown, errorsConfig?: ErrorI[]): void {
    let handled = false;

    if (isAxiosError(error)) {
      [
        ...(errorsConfig ?? []),
        ...this.defaultErrors.filter(
          (defaultError) => !errorsConfig?.some((err) => defaultError.code === err.code)
        ),
      ].forEach((errorConfig) => {
        if (errorConfig.code === error?.response?.status) {
          this._notificationService.show(errorConfig.errorText, errorConfig.type);
          errorConfig.callback?.();
          console.error(errorConfig.errorText);
          handled = true;
        }
      });
    }

    if (!handled) {
      this._notificationService.show(this._unexpectedErrorText, 'error');
      console.error(error);
    }
  }
}


    localStorage.ts
export const storage = {
  //TODO зарефачить это говно или скачать библиотеку
  get: (key: string, defaultValue?: string): string | null => {
    try {
      const result = localStorage.getItem(key);
      if (!result) return defaultValue ?? null;
      try {
        return JSON.parse(result) as string;
      } catch {
        return result;
      }
    } catch {
      return defaultValue ?? null;
    }
  },
  set: (key: string, value: string): void => {
    try {
      localStorage.setItem(key, value);
    } catch (error) {
      // toDo обработать ошибку
    }
  },
  remove(key: string): void {
    try {
      localStorage.removeItem(key);
    } catch (e) {
      console.error(e)
    }
  },
};


tsconfig.json
{
  "compilerOptions": {
    "target": "esnext",
    "useDefineForClassFields": true,
    "lib": ["esnext", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}


tsconfig.node.json
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}


vercel.json
{
  "rewrites": [
    {
      "source": "/(.*)",
      "destination": "/"
    }
  ]
}


vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
});


